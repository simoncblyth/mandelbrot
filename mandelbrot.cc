/**                                                    //S
mandelbrot.cc                                          //S
================                                       //S
                                                       //S
The Mandelbrot set is generated by sampling numbers    //S
in the complex plane, and determining whether under    //S
iteration of the polynomial::                          //S
                                                       //S
   z_(n+1) = c + z_n * z_n                             //S
                                                       //S
that the magnitude of z (|z_n|) remains within         //S
a configured region close to the origin within a       //S
configured max number of iterations.                   //S
                                                       //S
Images of the Mandelbrot set are created such          //S
that each pixel corresponds to a point c in the        //S
complex plane, and its colour depends on the number    //S
of iterations n before the iteration diverges outside  //S 
the configured region.                                 //S
                                                       //S
**/                                                    //S
                                                       //S
#include <complex>
#include <array>
#include <vector>
#include <cstdlib>
#include "NP.hh"

struct Mandelbrot
{
    const int    MIT, NX, NY ; 
    const double MZZ, aspect ;
    std::vector<double>  F ; 
    std::array<double,3> X ; 
    std::array<double,3> Y ; 
    NP*                  a ; 
    unsigned char*      aa ;
    Mandelbrot(); 
    static std::string Desc(const double* d3) ; //S
    std::string desc() const ;                  //S
}; 

inline Mandelbrot::Mandelbrot()
    :
    MIT(U::GetE<int>("MIT",255)),
    NX(1280), NY(720),
    MZZ(U::GetE<double>("MZZ",4.0)),
    aspect(double(NX)/double(NY)),
    F(*U::GetEnvVec<double>("FOCUS","-0.7,0,0.84375")),    
    a(NP::Make<unsigned char>(NY,NX)),
    aa(a->values<unsigned char>())
{
    X[0] = F[0] - F[2]*aspect ;  
    X[1] = F[0] + F[2]*aspect ; 
    X[2] = 2.*F[2]*aspect/double(NX) ; 

    Y[0] = F[1] - F[2] ; 
    Y[1] = F[1] + F[2] ; 
    Y[2] = 2.*F[2]/double(NY) ; 

    std::complex<double> c0(X[0],Y[0]) ; 

    a->set_meta<std::string>("FOCUS",Desc(F.data())); //S
    a->set_meta<double>("MZZ",MZZ);  //S
    a->set_meta<int>(   "MIT",MIT);  //S
    a->set_meta<double>("xmin", X[0] ) ;   //S
    a->set_meta<double>("xmax", X[1] ) ;   //S 
    a->set_meta<double>("ymin", Y[0] ) ;   //S
    a->set_meta<double>("ymax", Y[1] ) ;   //S

    const char* identity = getenv("IDENTITY"); 
    if(identity) a->set_meta<std::string>("IDENTITY",identity) ; 

    for(int iy=0 ; iy<NY ;iy++) for(int ix=0 ; ix<NX ;ix++) 
    {
        if(ix == 0 && (iy % 100 == 0))          //S
        std::cout << "iy " << iy << std::endl ; //S
                                                //S
        std::complex<double> c(ix*X[2], iy*Y[2]);
        std::complex<double> z(0.0, 0.0);
        int count(0) ; 
        while(std::norm(z)<MZZ && ++count < MIT-1) 
        {
            z=z*z + c0 + c;
        }
        aa[iy*NX+ix] = std::min(count,MIT) ; 
    }
}

std::string Mandelbrot::Desc(const double* d3) // static        //S
{                                                               //S
    std::stringstream ss ;                                      //S
    ss << "[" << d3[0] << "," << d3[1] << "," << d3[2] << "]" ; //S
    std::string str = ss.str();                                 //S
    return str ;                                                //S
}                                                               //S
std::string Mandelbrot::desc() const                            //S
{                                //S
    std::stringstream ss ;       //S
    ss << "Mandelbrot"           //S
       << " F" << Desc(F.data()) //S
       << " X" << Desc(X.data()) //S
       << " Y" << Desc(Y.data()) //S
       ;                         //S
    std::string s = ss.str();    //S
    return s ;                   //S
}                                //S
                                 //S
int main()
{
    Mandelbrot m ; 
    const char* path = "$FOLD/a.npy" ; 
    std::cout << "saving Mandelbrot array to " << path << std::endl ; 
    m.a->save(path); 
    std::cout << m.desc() << std::endl ; 
    return 0 ; 
}

